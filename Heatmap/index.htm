<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BTC/USDT H1 Live Forecast</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { margin: 0; background-color: #111; color: white; font-family: sans-serif; }
    #chart { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="chart"></div>
  <script>
    const symbol = "BTCUSDT";
    let fixedCandles = [];
    let currentCandle = null;

    function getStartOfDayUTC() {
      const now = new Date();
      return Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
    }

    async function fetchFixedH1() {
      const startTime = getStartOfDayUTC();
      const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&startTime=${startTime}`;
      const res = await fetch(url);
      const data = await res.json();

      const now = new Date();
      const currentHour = now.getUTCHours();

      fixedCandles = data.slice(0, currentHour); // Fixos
      currentCandle = data[currentHour];         // Candle atual (incompleto)
    }

    function averageFromList(list) {
      let o = 0, h = 0, l = 0, c = 0;
      list.forEach(candle => {
        o += parseFloat(candle[1]);
        h += parseFloat(candle[2]);
        l += parseFloat(candle[3]);
        c += parseFloat(candle[4]);
      });
      const n = list.length;
      return [
        list[list.length - 1][0] + 3600000,
        (o / n).toFixed(2),
        (h / n).toFixed(2),
        (l / n).toFixed(2),
        (c / n).toFixed(2),
      ];
    }

    function buildProjectedCandles() {
      const base = [...fixedCandles, currentCandle];
      const result = [...base];

      while (result.length < 24) {
        const avg = averageFromList(result);
        result.push(avg);
      }
      return result;
    }

    function plotChart() {
      const projected = buildProjectedCandles();

      const x = projected.map(c => new Date(c[0]));
      const open = projected.map(c => parseFloat(c[1]));
      const high = projected.map(c => parseFloat(c[2]));
      const low  = projected.map(c => parseFloat(c[3]));
      const close= projected.map(c => parseFloat(c[4]));

      const trace = {
        x, open, high, low, close,
        type: 'candlestick',
        increasing: { line: { color: 'lime' } },
        decreasing: { line: { color: 'red' } }
      };

      Plotly.newPlot('chart', [trace], {
        title: "BTC/USDT H1 • Real-Time + Forecast",
        xaxis: { rangeslider: { visible: false } },
        yaxis: { title: "Price (USDT)" },
        paper_bgcolor: "#111",
        plot_bgcolor: "#111",
        font: { color: "#fff" }
      });
    }

    function setupWebSocket() {
      const socket = new WebSocket("wss://stream.binance.com:9443/ws/btcusdt@kline_1h");

      socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        const k = data.k;
        if (k.x === false) {
          currentCandle = [
            k.t, k.o, k.h, k.l, k.c
          ];
          plotChart();
        }
      };
    }

    // Inicialização
    fetchFixedH1().then(() => {
      plotChart();
      setupWebSocket();
    });
  </script>
</body>
</html>
