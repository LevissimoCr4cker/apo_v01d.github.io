<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BTC/USDT H1 Live Forecast</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { margin: 0; background-color: #111; color: white; font-family: sans-serif; }
    #chart { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="chart"></div>
  <script>
    const symbol = "BTCUSDT";
    let fixedCandles = [];
    let currentCandle = null;

    function getStartOfDayUTC() {
      const now = new Date();
      return Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
    }

    async function fetchFixedH1() {
      const startTime = getStartOfDayUTC();
      const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&startTime=${startTime}`;
      const res = await fetch(url);
      const data = await res.json();

      const now = new Date();
      const currentHour = now.getUTCHours();

      fixedCandles = data.slice(0, currentHour); // Fixos
      currentCandle = data[currentHour];         // Candle atual (incompleto)
    }

    function averageFromList(list) {
      let o = 0, h = 0, l = 0, c = 0;
      list.forEach(candle => {
        o += parseFloat(candle[1]);
        h += parseFloat(candle[2]);
        l += parseFloat(candle[3]);
        c += parseFloat(candle[4]);
      });
      const n = list.length;
      return [
        list[list.length - 1][0] + 3600000,
        (o / n).toFixed(2),
        (h / n).toFixed(2),
        (l / n).toFixed(2),
        (c / n).toFixed(2),
      ];
    }

   function buildProjectedCandles() {
  const result = [...fixedCandles, currentCandle];

  while (result.length < 24) {
    const sum = { o: 0, h: 0, l: 0, c: 0 };

    for (let i = 0; i < result.length; i++) {
      sum.o += parseFloat(result[i][1]);
      sum.h += parseFloat(result[i][2]);
      sum.l += parseFloat(result[i][3]);
      sum.c += parseFloat(result[i][4]);
    }

    const n = result.length;
    const lastTimestamp = result[result.length - 1][0] + 3600000;

    const forecast = [
      lastTimestamp,
      (sum.o / n).toFixed(2),
      (sum.h / n).toFixed(2),
      (sum.l / n).toFixed(2),
      (sum.c / n).toFixed(2)
    ];

    result.push(forecast);
  }

  return result;
}


      Plotly.newPlot('chart', [trace], {
        title: "BTC/USDT H1 • Real-Time + Forecast",
        xaxis: { rangeslider: { visible: false } },
        yaxis: { title: "Price (USDT)" },
        paper_bgcolor: "#111",
        plot_bgcolor: "#111",
        font: { color: "#fff" }
      });
    }

    function setupWebSocket() {
      const socket = new WebSocket("wss://stream.binance.com:9443/ws/btcusdt@kline_1h");

      socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        const k = data.k;
        if (k.x === false) {
          currentCandle = [
            k.t, k.o, k.h, k.l, k.c
          ];
          plotChart();
        }
      };
    }

    // Inicialização
    fetchFixedH1().then(() => {
      plotChart();
      setupWebSocket();
    });
  </script>
</body>
</html>
