<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BTC Weekly 3D Candles (Three.js)</title>
  <style>body { margin:0; overflow:hidden; background:#111; }</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
const controls = new THREE.OrbitControls(camera, renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const light = new THREE.PointLight(0xffffff, 1);
light.position.set(50, 50, 50);
scene.add(light);

const gridHelper = new THREE.GridHelper(50, 50);
scene.add(gridHelper);

const grid = Array.from({ length: 7 }, () => Array(24).fill(null));

function clearScene() {
  for (let i = scene.children.length - 1; i >= 0; i--) {
    const obj = scene.children[i];
    if (obj.type === 'Mesh' || obj.type === 'Line') {
      scene.remove(obj);
    }
  }
  scene.add(light);
  scene.add(new THREE.AmbientLight(0xffffff, 0.7));
  scene.add(gridHelper);
}

function addCandle(x, y, open, close, high, low, color=0x00ff00) {
  const bodyHeight = Math.abs(close - open);
  const bodyY = (open + close) / 2;
  const geometry = new THREE.BoxGeometry(1, bodyHeight, 1);
  const material = new THREE.MeshStandardMaterial({ color });
  const cube = new THREE.Mesh(geometry, material);
  cube.position.set(x, bodyY, y);
  scene.add(cube);

  const wickMat = new THREE.LineBasicMaterial({ color: 0xffffff });
  const wickGeo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(x, low, y),
    new THREE.Vector3(x, high, y)
  ]);
  const wick = new THREE.Line(wickGeo, wickMat);
  scene.add(wick);
}

async function fetchInitialData() {
  const now = new Date();
  const sunday = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() - now.getUTCDay()));
  const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&startTime=${sunday.getTime()}`);
  const candles = await response.json();

  candles.forEach(c => {
    const date = new Date(c[0]);
    const day = date.getUTCDay(), hour = date.getUTCHours();
    const open = +c[1], high = +c[2], low = +c[3], close = +c[4];
    grid[day][hour] = { open, high, low, close };
  });

  updateForecast();
}

function updateForecast() {
  clearScene();
  const prices = grid.flat().filter(c => c).map(c => c.close);
  let mean = prices.reduce((a, b) => a + b, 0) / prices.length;
  const now = new Date(), d = now.getUTCDay(), h = now.getUTCHours();

  for (let day = 0; day < 7; day++) {
    for (let hour = 0; hour < 24; hour++) {
      let candle = grid[day][hour];
      if (!candle) {
        const open = mean;
        const close = mean + (Math.random() - 0.5) * 200;
        const high = Math.max(open, close) + Math.random() * 100;
        const low = Math.min(open, close) - Math.random() * 100;
        candle = { open, high, low, close };
        grid[day][hour] = candle;
        mean = (mean + close) / 2;
      }
      const color = candle.close >= candle.open ? 0x00ff00 : 0xff0000;
      addCandle(hour, day, candle.open / 100, candle.close / 100, candle.high / 100, candle.low / 100, color);
    }
  }
}

const ws = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@kline_1h');
ws.onmessage = (e) => {
  const k = JSON.parse(e.data).k;
  const date = new Date(k.t);
  const d = date.getUTCDay(), h = date.getUTCHours();
  const open = +k.o, high = +k.h, low = +k.l, close = +k.c;
  grid[d][h] = { open, high, low, close };
  updateForecast();
};

camera.position.set(20, 30, 70);
controls.update();

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
fetchInitialData();
</script>
</body>
</html>
