<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BTC Weekly 3D Candles (Three.js)</title>
  <style>body { margin:0; overflow:hidden; background:#111; }</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
const controls = new THREE.OrbitControls(camera, renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const light = new THREE.PointLight(0xffffff, 1);
light.position.set(50, 50, 50);
scene.add(light);

const grid = Array.from({ length: 7 }, () => Array(24).fill(null));

function addCandle(x, y, open, close, high, low, color=0x00ff00) {
  const bodyHeight = Math.abs(close - open);
  const bodyY = (open + close) / 2;
  const geometry = new THREE.BoxGeometry(1, bodyHeight, 1);
  const material = new THREE.MeshStandardMaterial({ color });
  const cube = new THREE.Mesh(geometry, material);
  cube.position.set(x, bodyY, y);
  scene.add(cube);

  const wickMat = new THREE.LineBasicMaterial({ color: 0xffffff });
  const wickGeo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(x, low, y),
    new THREE.Vector3(x, high, y)
  ]);
  const wick = new THREE.Line(wickGeo, wickMat);
  scene.add(wick);
}

async function fetchInitialData() {
  const now = new Date();
  const sunday = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() - now.getUTCDay()));
  const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&startTime=${sunday.getTime()}`);
  const candles = await response.json();

  candles.forEach(c => {
    const date = new Date(c[0]);
    const day = date.getUTCDay(), hour = date.getUTCHours();
    const open = +c[1], high = +c[2], low = +c[3], close = +c[4];
    grid[day][hour] = { open, high, low, close };
    const color = close >= open ? 0x00ff00 : 0xff0000;
    addCandle(hour, day, open/1000, close/1000, high/1000, low/1000, color);
  });

  updateForecast();
}

function updateForecast() {
  const prices = grid.flat().filter(c => c).map(c => c.close);
  let mean = prices.reduce((a, b) => a + b, 0) / prices.length;
  const now = new Date(), d = now.getUTCDay(), h = now.getUTCHours();

  for (let day = d; day < 7; day++) {
    for (let hour = (day === d ? h + 1 : 0); hour < 24; hour++) {
      const open = mean;
      const close = mean + (Math.random() - 0.5) * 200;
      const high = Math.max(open, close) + Math.random() * 100;
      const low = Math.min(open, close) - Math.random() * 100;
      grid[day][hour] = { open, high, low, close };
      const color = close >= open ? 0x00ff00 : 0xff0000;
      addCandle(hour, day, open/1000, close/1000, high/1000, low/1000, color);
      mean = (mean + close) / 2;
    }
  }
}

const ws = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@kline_1h');
ws.onmessage = (e) => {
  const k = JSON.parse(e.data).k;
  const date = new Date(k.t);
  const d = date.getUTCDay(), h = date.getUTCHours();
  const open = +k.o, high = +k.h, low = +k.l, close = +k.c;
  grid[d][h] = { open, high, low, close };
  const color = close >= open ? 0x00ff00 : 0xff0000;
  addCandle(h, d, open/1000, close/1000, high/1000, low/1000, color);
  updateForecast();
};

camera.position.set(20, 15, 40);
controls.update();

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
fetchInitialData();
</script>
</body>
</html>
